# 질문

- 본편584, 기초편 398p. ArrayList와 LinkedList에서 삽입/삭제가 일어나는 과정을 말씀해주세요

```
ArrayList
삽입 : 특정 위치 다음에 존재하는 데이터를 복사 후, 데이터를 삽입한 뒤에 다시 shift 해준다.
따라서 시간복잡도는 O(N)
삭제 : 마찬가지로 데이터를 삭제 후, 양옆 데이터를 재배치하는 작업이 필요해서 O(N)

LinkedList
삽입 : 노드를 생성하고, 이전 노드의 링크를 새 노드와 연결한다. 새 노드의 링크를 다음 노드와 연결한다.
삭제 : 기존 노드 기준으로 이전 노드의 링크를 다음 노드와 연결한다. 기존 노드는 삭제한다.
```

- 그렇다면, 중간 인덱스와 시작,끝 인덱스를 삽입/삭제 하고자 할 땐 둘 중 어떤게 적합하고, 그 이유를 설명해주세요

```
끝의 경우 ArrayList는 shift과정이 필요없어서 O(1)의 시간복잡도가 걸리기에 ArrayList
시작의 경우 ArrayList의 shift과정이 필요해서 LinkedList가 O(1)로 LinkedList
중간의 경우 요소간의 연결만 변경해주면 되어서 LinkedList, ArrayList 모두 
시간복잡도는 O(N)이지만, 데이터의 사이즈와 순차적 데이터 여부에 따라 어떤 것을 선택해야 할 지 정해야 함
```

- 큐와 스택은 각각 어떤 자료구조를 쓰는 것이 좋을까요?

```
스택 : LIFO 구조, 순차적으로 데이터를 추가하고 삭제하기 때문에 ArrayList
큐 : FIFO 구조, 데이터를 꺼낼 때 항상 첫번째 인덱스를 삭제하므로 LinkedList
```

- comparable과 comparator의 차이에 대해서 말씀해주세요

```
comparable : 기존 정렬기준을 구현하는데 사용
comparator : 기존 정렬기준 외에 다른 기준을 세워서 정렬하고 싶을 때 사용
```

- HashSet은 순서를 보장하지 않습니다. 그 이유에 대해서 아시나요?

```
기본적으로 HashSet은 HashMap을 사용합니다.
HashSet은 해시함수를 사용하여 해당 원소의 위치를 결정하게 되는데, 이 때 동일한 해시 코드,
즉 Collision이 발생하게 되면 동적으로 HashSet이 크기를 조절하게되며, 이 과정에서 순서가 바뀔 수 있습니다.
순서를 보장하고 싶다면 LinkedHashSet을 사용하는 것이 좋습니다.
```

- 이진 탐색 트리의 데이터 저장 과정과 시간복잡도를 말씀해주세요

```
1. 루트 노드에 첫 원소가 들어갑니다.
2. 부모 노드보다 작다면 왼쪽, 크다면 오른쪽에 넣어줍니다.
시간복잡도는 탐색, 삽입, 삭제 모두 O(logN) 입니다.
```

- 이진 탐색 트리의 worst case 시간복잡도는 얼마이며, 어떤 경우에 발생하고 그를 해결하려면 어떻게 해야하는지 간단하게 말씀해주세요

```
그래프가 한쪽으로 치우쳐진 경우에 worst case가 됩니다.
이 때는 LinkedList와 다를게 없어지기 때문에 시간복잡도가 N이되며, 이를 해결하려면 트리의 높이를 가능한 낮게 유지해야 합니다. 대표적으로는 AVL 트리와 Red-Black 트리가 있습니다.
```

- HashMap에서 Collision이 발생하면 어떻게 해결해야 하나요?

```
Open Addressing과 separate chaining 기법이 있습니다.
Open Addressing은 미리 정한 규칙에 따라 해시맵의 비어있는 공간을 탐색하는 방법입니다.
크게 Linear Probing, Quadratic Probing, double hashing이 있습니다.

separate chaining은 LinkedList를 활용하는 방법입니다.
충돌이 발생하면 LinkedList에 노드를 추가하여 데이터를 저장합니다. 충돌이 발생하면 연결된 LinkedList에서 값을 가져오는 방법입니다.
```