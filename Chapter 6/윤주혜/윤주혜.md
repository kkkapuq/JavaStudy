# Chapter 6. 객체지향 프로그래밍 1

## 01. 객체지향 언어

### 객체지향 언어란?

- 기존의 프로그래밍 언어에 새로운 규칙을 추가한 보다 발전된 형태의 것
- 코드 간 서로 관계를 맺어 줌으로써 유기적으로 프로그램 구성이 가능해짐

### 객체지향언어의 특징

- **코드의 재사용성**이 높음
  - 새로운 코드 작성 시 기존의 코드를 이용해 쉽게 작성 가능
- 코드의 관리가 용이함 - **유지보수** 용이
  - 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드 변경 가능
- 신뢰성이 높은 프로그래밍 가능
  - 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작 방지



## 02. 클래스와 객체

- 클래스를 정의하고 클래스를 통해 객체를 생성하는 이유는, 설계도를 통해 제품을 만드는 것과 같이 하나의 설계도를 잘 만들어 놓으면 제품을 만드는 일이 쉬워지기 때문이다.

### 클래스란?

- 객체를 정의해놓은 것, 객체의 설계도 또는 틀
- 객체를 생성하는데 사용됨
- 객체의 모든 속성과 기능이 정의되어 있음

### 객체란?

- 실제로 존재하는 것, 사물 또는 개념
- 객체가 가지고 있는 기능과 속성에 따름
- 유형의 객체: 책상, 의자, 자동차, TV와 같은 사물
- 무형의 객체: 수학공식, 프로그램 에러와 같은 논리나 개념



## 03. 객체의 구성요소 - 속성과 기능

### 객체의 구성요소

> 객체는 다수의 속성과 다수의 기능을 가짐 (속성과 기능의 집합)

- 속성
- 기능



## 04. 객체와 인스턴스

- 클래스의 인스턴스화: 클래스로부터 객체를 만드는 과정
- 클래스의 인스턴스: 어떤 클래스로부터 만들어진 객체

- ex: TV 클래스로부터 만들어진 객체 = TV클래스의 인스턴스
- 인스턴스는 객체와 같은 의미이나, 객체는 **모든 인스턴스를 대표**하는 포괄적인 의미이고 인스턴스는 어떤 클래스로부터 만들어진 것인지를 보다 강조(**특정 클래스**로부터 만들어진 객체를 의미)



## 05. 한 파일에 여러 클래스 작성하기

- 하나의 소스파일에 둘 이상의 클래스 정의 가능

- 소스파일의 이름은 public class의 이름과 일치해야 함
  - 만약 public class가 없으면 어떤 클래스의 이름이어도 상관 없음



## 06. 객체의 생성과 사용

- 클래스로부터 인스턴스 생성하는 방법

  ```java
  클래스명 변수명; // 클래스의 객체를 참조하기 위한 참조변수를 선언
  변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장
  
  Tv t; // Tv 클래스 타입의 참조변수 t를 선언
  t = new Tv(); // Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장
  ```

- 예제6-1

  ```java
  class Ex6_1 {
    public static void main(String[] args) {
      Tv t; 						// 1. Tv인스턴스 참조하기 위한 변수 t 선언
      t = new Tv();			// 2. Tv인스턴스 생성
      t.channel = 7;		// 3. Tv인스턴스 멤버변수 channel 값 7
      t.channelDown();  // 4. Tv인스턴스 메서드 ChannelDown() 호출
      System.out.printIn("현재 채널은 " + t.channel + " 입니다."); // 결과: 현재 채널은 6 입니다.
    }
  }
  
  class Tv {
    // Tv의 속성(멤버변수)
    String color;
    boolean power;
    int channer;
    
    // Tv의 기능(메서드)
    void power()	{ power = !power; }
    void channelUp()	{ ++channel; }
    void channeldown() 	{ --channel; }
  }
  ```

  1. 메모리에 참조변수 t를 위한 공간 마련됨. 인스턴스 생성 전으로 참조변수로 아무것도 할 수 없음
  2. 연산자 new에 의해 인스턴스 메모리의 빈 공간에 생성됨. 
     - 각 자료형에 해당하는 기본값으로 초기화됨. (참조형 null, boolean은 false, int는 0)
     - 대입연산자(=)에 의해 생성된 객체의 주소값이 참조변수 t에 저장되어 참조변수 t를 통해 Tv인스턴스에 접근 가능
       - 인스턴스를 다루기 위해서는 참조변수가 반드시 필요하다
       - 참조변수의 타입은 인스턴스의 타입과 일치해야 함
  3. 인스턴스의 멤버변수(속성)를 사용하려면 '참조변수.멤버변수' 사용

- 같은 클래스로부터 생성되었을지라도 각 인스턴스의 속성(멤버변수)은 서로 다른 값을 유지할 수 있음



## 08. 객체배열

- 객체 배열 안에 객체가 저장되는 것은 아니고, **객체의 주소**가 저장됨.

- 객체배열: 참조변수들을 하나로 묶은 참조변수 배열

  ```java
  Tv[] tvArr = new Tv[3]; // 길이가 3인 Tv타입의 참조변수 배열 생성,  기본값 null로 자동 초기화
  
  // 객체를 생성해서 배열의 각 요소에 저장
  tvArr[0] = new Tv();
  tvArr[1] = new Tv();
  tvArr[2] = new Tv();
  ```



## 09. 클래스의 정의(1) - 데이터와 함수의 결합

> 프로그래밍적 관점에서의 클래스의 정의와 의미

### 프로그래밍언어에서 데이터 처리를 위한 데이터 저장형태의 발전 과정

1. 변수: 하나의 데이터를 저장할 수 있는 공간
2. 배열: 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
3. 구조체: 서로 관련된 **여러 데이터를 종류에 관계없이** 하나의 집합으로 저장할 수 있는 공간
4. 클래스: 데이터와 함수의 결합(구조체 + 함수)
   - 서로 관계가 깊은 변수와 함수를 함께 다룰 수 있게 함.



## 10. 클래스의 정의(2) - 사용자 정의 타입

- 사용자 정의 타입: 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것

- 객체지향언어에서는 클래스가 곧 사용자 정의 타입

- 기본형의 개수는 8개로 정해져 있으나, 참조형의 개수는 정해져 있지 않음. 프로그래머가 새로운 타입 추가 가능

  ```java
  // 비객체지향적 코드
  int hour1, hour2, hour3;
  int minute1, minute2, minute3;
  float second1, second2, second3;
  
  int[] hour = new int[3];
  int[] minute = new int[3];
  float[] second = new float[3];
  
  // 객체지향적 코드
  class Time {
    int hour;
    int minute;
    float second;
  }
  
  Time t1 = new Time();
  Time t2 = new Time();
  Time t3 = new Time();
  
  Time[] t = new Time[3];
  t[0] = new Time();
  t[1] = new Time();
  t[2] = new Time();
  ```



## 11. 선언위치에 따른 변수의 종류

### 변수

> 변수의 선언 위치에 따라 결정됨

| 변수의 종류               | 선언위치                                                  | 생성시기                    |
| ------------------------- | --------------------------------------------------------- | --------------------------- |
| 클래스 변수               | 클래스 영역                                               | 클래스가 메모리에 올라갈 때 |
| 인스턴스 변수             | 클래스 영역                                               | 인스턴스가 생성되었을 때    |
| 지역변수 (local variable) | 클래스 영역 이외의 영역(메서드, 생성자, 초기화 블럭 내부) | 변수 선언문이 수행되었을 때 |

```java
class Variables {
  int iv; // 인스턴스 변수
  static int cv; // 클래스 변수(static변수, 공유변수) => 클래스 영역
  
  void method() {
    int lv = 0; // 지역변수 => 메서드영역
  }
}
```

- 인스턴스 변수
  - 인스턴스 변수의 값을 읽어오거나 저장하려면 먼저 인스턴스 생성해야 함
  - 인스턴스마다 별도의 저장공간을 가짐
  - 서로 다른 값을 가질 수 있음
  - 인스턴스마다 고유한 상태를 유지해야하는 속성의 경우 인스턴스 변수로 선언
- 클래스 변수
  - 인스턴스 변수 앞에 static을 붙여 선언
  - 모든 인스턴스가 공통된 저장공간(변수)을 공유함 (인스턴스 변수: 인스턴스마다 독립적인 저장공간)
  - 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야 하는 속성의 경우 클래스 변수로 선언
  - 인스턴스 변수와 달리 인스턴스를 생성하지 않고 언제라도 바로 사용 가능 '클래스이름.클래스 변수'

- 지역변수
  - 메서드 내에서만 사용 가능
  - 메서드가 종료되거나, 선언된 블럭{}을 벗어나면 소멸되어 사용할 수 없음



## 12. 클래스 변수와 인스턴스 변수

- 인스턴스 변수는 인스턴스가 생성될 때 마다 생성되므로, **인스턴스마다 각기 다른 값**을 유지

- 클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로, **항상 공통된 값**

  ```java
  class Card {
    String kind; // 무늬
    int number; // 숫자
    
    static int width = 100; // 폭
    static int height = 250; // 높이
  }
  ```



## 14. 메서드란?

- 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것
- 수학의 함수와 달리, 메서드는 입력값, 출력값이 없을 수도 있음

- 내부가 보이지 않는 '블랙박스(black box)' 라고도 함

- 메서드 정의: 선언부와 구현부를 작성하는 것

  ```java
  반환타입 메서드이름 (타입 변수명, 타입 변수명, ...) // => 선언부
  {
    // 메서드 호출 시 수행될 코드 => 구현부
  }
  ```

  

## 15. 메서드의 선언부

- 메서드 선언부: 메서드가 작업을 수행하기 위해 어떤 값들을 필요로 하고 작업의 결과로 어떤 타입의 값을 반환하는지에 대한 정보 제공, 추후에 변경사항이 발생하지 않도록 신중히 작성해야 함 (변경 시 호출되는 모든 곳이 함께 변경되어야 하기 때문)

  - 메서드의 이름
  - 매개변수 선언
    - 매개변수: 메서드가 작업을 수행하는데 필요한 값들(입력)을 제공받기 위한 것
    - 필요한 값의 개수만큼 변수 선언
    - 일반적인 변수 선언과 달리 두 변수의 타입이 같아도 변수의 타입을 생략할 수 없음

  - 반환타입
    - 메서드의 작업수행 결과인 '반환값(return value)'의 타입
    - 반환값이 없는 경우 반환타입으로 void 적음



## 16. 메서드의 구현부

- 메서드 구현부: 선언부 다음에 오는 괄호{}
- 메서드를 호출했을 때 수행될 문장
- return 문
  - 메서드의 반환타입이 void가 아닌 경우 구현부{} 안에 'return 반환값'이 반드시 포함되어야 함
  - 반환값의 타입은 반환타입과 일치하거나 적어도 자동 현변환이 가능한 것이어야 함
  - 입력(매개변수)은 여러개일수 있어도 출력(반환값)은 최대 하나만 허용
- 지역변수(local variable)
  - 메서드 내에 선언된 변수
  - 서로 다른 메서드라면 같은 이름의 변수 선언 가능
  - 매개변수도 메서드 내에 선언된 것으로 간주하여 지역변수임



## 17. 메서드의 호출

### 인수(argument)와 매개변수(parameter)

- 인수(인자): 메서드를 호출할 때 괄호()안에 지정해준 값
  - 인자의 개수와 순서는 호출된 메서드에 선언된 매개변수와 일치해야 함
  - 인자의 타입은 매개변수의 타입과 일치하거나 자동 형변환이 가능해야 함
  - 다르면 컴파일러 에러 발생



## 20. return문

- 현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아감
- 반환값의 유무에 관계없이 모든 메서드에는 적어도 하나의 return문이 있어야 함
  - 없으면 컴파일 에러 발생
  - 반환값이 void인 경우, 컴파일러가 자동적으로 메서드 마지막에  return;을 추가해줌



## 22. 호출스택(call stack)

- 메서드 작업에 필요한 메모리 공간 제공

- 메서드 호출 

  -> 호출스택에 호출된 메서드를 위한 메모리 할당 받음 

  -> 메서드 작업 수행동안 지역변수들과 연산의 중간 결과 등 저장 

  ​	(호출스택 제일 위에 있는 메서드가 현재 실행중인 메서드, 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드) 

  -> 메서드 작업 후 할당되었던 메모리 공간 반환되어 비워짐



## 23~24. 기본형 매개변수, 참조형 매개변수

- 메서드 호출 시, 매개변수 지정값을 메서드의 매개변수에 복사해서 넘겨줌
- 기본형: 기본형 값 복사, read only (변수의 값을 읽기만 할 수 있음, 원본에 영향 불가능)
- 참조형: 인스턴스의 주소 복사, read & write (값을 읽어오고 변경도 가능)



## 25. 참조형 반환타입

- 참조형 타입: '객체의 주소' = 정수값 반환



## 26. static 메서드와 인스턴스 메서드

- static 메서드: 클래스 메서드
  - 클래스 메서드는 '클래스이름.메서드이름(매개변수)' 호출 가능
  - 메서드 중에서 인스턴스와 관계없는 메서드를 클래스 메서드(static 메서드)로 정의
    - 인스턴스 변수를 사용하지 않는다고 해서 반드시 클래스 메서드로 정의해야하는 것은 아니지만 특별한 이유가 없으면 그렇게 하는 것이 일반적
- static 안 붙어 있는 메서드: 인스턴스 메서드
  - 반드시 객체를 생성해야만 호출 가능 -> 인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는, 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 함. 인스턴스 변수는 인스턴스(객체)를 생성해야만 만들어지므로, 인스턴스 메서드 역시 인스턴스를 생성해야만 호출할 수 있음

- 클래스: 데이터(변수)와 데이터에 관련된 메서드의 집합
- 멤버변수: 인스턴스변수+static변수



## 28. static을 언제 붙여야 할까?

- 클래스 설계 시, 멤버변수 중 **모든 인스턴스에 공통적으로 사용**하는 것에 static 붙임
  - 모든 인스턴스에서 같은 값이 유지되어야 하는 변수
    - 생성된 각 인스턴스는 서로 독립적이기 때문에 각 인스턴스의 변수는 서로 다른 값 유지
- 클래스 변수(static 변수)는 인스턴스를 생성하지 않아도 사용 가능
  - static 변수는 클래스가 메모리에 올라갈 때 자동적으로 인스턴스 생성됨
- 클래스 메서드(static메서드)는 인스턴스 변수 사용 불가
  - 인스턴스변수는 반드시 인스턴스가 존재해야 함
  - 클래스메서드는 인스턴스 생성 없이 호출가능하므로 클래스 메서드 호출 시 인스턴스가 존재하지 않을 수도 있음
  - 반면, 인스턴스변수나 인스턴스메서드에서는 static이 붙은 멤버들을 사용하는 것이 언제나 가능함
    - 인스턴스 변수 존재 -> static 변수가 이미 메모리에 존재하다는 것 의미
- 메서드 내에서 **인스턴스 변수를 사용하지 않는다면**, static 붙이는 것 고려
  - 메서드 작업내용 중 인스턴스변수를 필요로 하면  static을 붙일 수 없음
  - 인스턴스 변수를 필요로 하지 않으면 static 붙임 -> 메서드 호출시간이 짧아지므로 성능이 향상됨.
  - static 안 붙인 메서드(인스턴스메서드)는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요함



## 29. 메서드 간의 호출과 참조

- 같은 클래스에 속한 멤버들 간 별도 인스턴스 생성 없이 서로 참조 또는 호출 가능
- 클래스 멤버가 인스턴스 멤버를 참조 또는 호출하는 경우 인스턴스 생성해야 함
  - 인스턴스 멤버가 존재하는 시점에 클래스 멤버 항상 존재하나, 클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을수도 있기 때문



## 30. 오버로딩(overloading)

- 메서드 오버로딩: 한 클래스 내에 같은 이름의 메서드를 여러개 정의하는 것

- 오버로딩 성립 조건

  - 메서드 이름이 같아야 한다
  - 매개변수의 개수 또는 타입이 달라야 한다
  - 반환 타입은 관계 없다

  ```java
  void printIn()
  void printIn(boolean x)
  void printIn(char x)
  void printIn(char[] x)
  void printIn(double) ...
  ```



## 32. 생성자(constructor) 

- 생성자: 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'

  - 인스턴스 초기화: 인스턴스변수들을 초기화하는 것
  - 메서드처럼 클래스 내에 선언되고 리턴값이 없음

- 생성자 조건

  - 생성자의 이름은 클래스의 이름과 같아야 함
  - 생성자는 리턴값이 없다.

  ```java
  class Point {
    Point() { // 매개변수가 없는 생성자
      ...
    }
    
    Point(int x, int y) { // 매개변수가 있는 생성자
      
    }
  }
  ```

- 연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아님



## 33. 기본 생성자(default constructor)

- 모든 클래스에는 반드시 하나 이상의 생성자가 정의되어야 함
- 컴파일러가 제공하는 '기본 생성자'가 있어 클래스에 생성자 정의 없이도 인스턴스 생성 가능한 것

- 기본 생성자는 클래스에 정의된 생성자가 하나도 없을 때만 컴파일러에 의해 추가됨



## 34. 매개변수가 있는 생성자

- 인스턴스 생성 시 결정 사항
  1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
  2. 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?



## 36. 생성자에서 다른 생성자 호출하기 - this()

- 생성자 간 서로 호출 가능한 조건

  - 생성자의 이름으로 클래스이름 대신 this 사용
  - 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능
    - 생성자 내에서 초기화 작업 도중 다른 생성자 호출 시, 호출된 다른 생성자 내에서도 멤버변수들의 값을 초기화 할 것이므로 다른 생성자 호출 이전의 초기화작업이 무의미해질 수 있음

  ```java
  Car(String color) {
    door = 5;							// 첫 번째 줄
    Car(color, "auto", 4) // 에러 1. 생성자의 두 번째줄에서 다른 생성자 호출
  }												// 에러 2. this(color, "auto", 4);로 해야함
  ```

- 서로 호출하도록 하여 유기적 연결 시 더 좋은 코드 가능, 유지보수 용이



## 37. 객체 자신을 가리키는 참조변수 - this

- 생성자의 매개변수로 인스턴스변수들의 초기값을 제공받는 경우가 많기 때문에 매개변수 이름 = 인스턴스변수 이름인 경우가 자주 있음 -> this를 통해 구별
- 생성자를 포함한 모든 인스턴스메서드에는 자신이 관련된 인스턴스를 가리키는 참조변수 'this'가 지역변수로 숨겨진 채 존재
- this: 인스턴스 자신을 가리키는 **참조변수**, 인스턴스의 주소가 저장되어 있음.
  - 참조변수를 통해 인스턴스 멤버에 접근할 수 있는 것처럼 this로 인스턴스변수에 접근 가능
  - this 사용은 인스턴스멤버만 가능.   static메서드(클래스 메서드)에서는 인스턴스 멤버들 사용 불가능 -> static메서드는 인스턴스 생성하지 않고도 호출될 수 있으므로 호출된 시점에 인스턴스가 존재하지 않을 수도 있음
- this(), this(매개변수): **생성자**, 같은 클래스의 다른 생성자를 호출할 때 사용



## 38. 변수의 초기화

- 변수의 초기화: 변수를 선언하고 처음으로 값을 저장하는 것

- 멤버변수의 초기화: 자동적으로 변수의 자료형에 맞는 기본값으로 초기화됨
- 지역변수의 초기화: 사용 전 **반드시 초기화**해야 함



## 39. 멤버변수의 초기화

- 멤버변수는 각 타입의 기본값으로 자동 초기화 됨

1. 클래스 변수 초기화 -> 인스턴스 변수 초기화

2. 자동 초기화 -> 명시적 초기화(단순) -> 초기화 블럭, 생성자(복잡)

### 명시적 초기화(explicit initialization)

- 변수를 선언과 동시에 초기화하는 것
- 초기화 방법 중 가장 우선적으로 고려

### 초기화 블럭(initialization block)

- 복잡한 초기화 작업이 필요할 때 사용

- 클래스 초기화 블럭: 클래스 변수의 초기화에 사용

  - 인스턴스 초기화 블럭 앞에 static 붙임

- 인스턴스 초기화 블럭: 인스턴스변수의 초기화에 사용

  - 클래스 내에 블럭{}을 만들고 그 안에 코드 작성

  ```java
  class Ex6_14 {
    static {
      System.out.printIn("static {}"); // 클래스 초기화 블럭 (1)
    }
    {
      System.out.printIn("{}"); // 인스턴스 초기화 블럭 // (3), (6)
    }
    
    public Ex6_14() {
      System.out.printIn("생성자"); // (4), (7)
    }
    
    public static void main(String[] args) {
      System.out.printIn("Ex6_14 bt = new Ex6_14(); "); // (2)
      Ex6_14 bt = new Ex6_14(); 
      
      System.out.printIn("Ex6_14 bt2 = new Ex6_14(); "); // (5)
      Ex6_14 bt2 = new Ex6_14();
    }
  }
  ```

  ```java
  static {}
  Ex6_14 bt = new Ex6_14();
  {}
  생성자
  Ex6_14 bt2 = new Ex6_14();
  {}
  생성자
  ```

  - 클래스 초기화 블럭은 처음 메모리에 로딩될 때 한 번만 수행
  - 인스턴스 초기화 블럭은 **인스턴스가 생성될 때마다 수행**

  ```java
  class Ex6_15 {
    static int[] arr = new int[10]; // 명시적 초기화 배열 arr 생성
    
    static { // 클래스 초기화 블럭 - 배열이나 예외처리가 필요한 초기화에서 복잡한 작업 수행
      for(int i=0;i<arr.length;i++) {
        // 1과 10 사이의 임의의 값을 배열 arr에 저장
        arr[i] = (int)(Math.random()*10) + 1;
      }
    }
    
    public static void main(String[] args) {
      for(int i=0; i<arr.length;i++)
        System.out.printIn("arr["+i+"] :" + arr[i]);
    }
  }
  ```



## 연습문제

### 6-1.

```java
class Student {
  String name; // 학생이름
  int ban; // 반
  int no; // 번호
  int kor; // 국어점수
  int eng; // 영어점수
  int math; // 수학점수
}
```



### 6-2.

```java
class Exercise6_2 {
  public static void main(String args[]) {
    Student s = new Student("홍길동",1,1,100,60,76);
    String str = s.info();
    System.out.println(str);
  }
}

class Student {
  String name;
  int ban;
  int no;
  int kor;
  int eng;
  int math;
  
  Student(String name, int ban, int no, int kor, int eng, int math) {
    this.name = name;
    this.ban = ban;
    this.no = no;
    this.kor = kor;
    this.eng = eng;
    this.math = math;
	}
  
  public String info() {
    return name+","+ban+","+no+","+kor+","+eng+","+math+","+(kor+eng+math)+","+((int)((kor+eng+math) / 3f*10+0.5f) / 10f);
  }
}
```



### 6-3. 

```java
class Exercise6_2 {
  public static void main(String args[]) {
    Student s = new Student();
    s.name = "홍길동";
    s.ban = 1;
    s.no = 1;
    s.kor = 100;
    s.eng = 60;
    s.math = 76;
    
    System.out.println("이름:" + s.name);
    System.out.println("총점:" + s.getTotal());
    System.out.println("평균:" + s.getAverage());
  }
}

class Student {
  String name;
  int ban;
  int no;
  int kor;
  int eng;
  int math;
  
  Student() {}
  Student(String name, int ban, int no, int kor, int eng, int math) {
    this.name = name;
    this.ban = ban;
    this.no = no;
    this.kor = kor;
    this.eng = eng;
    this.math = math;
	}
  
  int getTotal {
    return (kor+eng+math);
  }
  
  float getAverage {
    return (int)(getTotal()/3f*10+0.5f)/10f;
  }
}
```



### 6-4.

```java
class Exercise6_4 {
  static double getDistance(int x, int y, int x1, int y1) {
    return Math.sqrt((x-x1)*(x-x1) + (y-y1)*(y-y1));
  }
  
  public static void main(String[] args) {
    System.out.printIn(getDistance(1,1,2,2));
  }
}
```



### 6-5.

```java
class PlayingCard {
  int kind; // 인스턴스 변수 kind
  int num; // 인스턴스 변수 kind
  
  static int width; // 클래스 변수 width
  static int height; // 클래스 변수 height
  
  PlayingCard(int k, int n) { // 지역변수 k, n
    kind = k;
    num = n; 
  }
  
  public static void main(String[] args) { // 지역변수 args
    PlayingCard card = new PlayingCard(1,1); // 지역변수 card
  }
}
```



### 6-6.

```java
class MyPoint {
  int x;
  int y;
  MyPoint(int x, int y) {
    this.x = x;
    this.y = y;
  }
  double getDistance(int x1, int y1) { 
    return Math.sqrt((x-x1)*(x-x1) + (y-y1)*(y-y1));
  }
}
class Exercise6_6 {
  public static void main(String args[]) {
    MyPoint p = new MyPoint(1,1);
    
    System.out.println(p.getDistance(2,2));
  }
}
```





## 질문

- 인스턴스를 다루기 위해서 참조변수가 왜 반드시 필요할까요?
  - 인스턴스와 참조변수의 관계는 마치 TV와 TV리모콘의 관계와 같음. TV리모콘(참조변수)을 사용하여 TV(인스턴스)를 다루기 때문. 인스턴스는 오직 참조변수를 통해서만 다룰 수 있음
    - 왜 오직 참조변수로만 다룰 수 있나요?

- 참조형 반환타입 객체의 주소 반환? 
- 인스턴스 메서드는 왜 반드시 객체를 생성해야만 호출이 가능할까요?
  - 인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는, 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 함. 인스턴스 변수는 인스턴스(객체)를 생성해야만 만들어지므로, 인스턴스 메서드 역시 인스턴스를 생성해야만 호출할 수 있음
- 인스턴스 메서드의 실행 시 호출되어야할 메서드를 찾는 과정은 뭔가요?

- 생성자 인스턴스 초기화해야하는 이유?

- 인스턴스 초기화 블럭이 인스턴스 생성마다 수행되는 이유
