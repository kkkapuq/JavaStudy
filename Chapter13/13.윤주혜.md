# 13. 쓰레드

## 01. 프로세스와 쓰레드

- 프로세스: 실행중인 프로그램, OS로부터 실행에 필요한 자원(메모리)을 할당받아 프로세스가 됨
- 프로세스 = 프로그램을 수행하는 데 필요한 데이터와 메모리 등의 자원 + 쓰레드
- 쓰레드: 프로세스의 자원을 이용해서 실제로 작업을 수행하는 것
- 모든 프로세스에는 최소한 하나 이상의 쓰레드 존재
- 멀티쓰레드 프로세스: 둘 이상의 쓰레드를 가진 프로세스



## 02. 멀티쓰레딩의 장단점

### 장점

- CPU의 사용률을 향상시킴
- 자원을 보다 효율적으로 사용할 수 있음
- 사용자에 대한 응답성이 향상됨
- 작업이 분리되어 코드가 간결해짐



- 싱글쓰레드로 서버 프로그램을 작성하면, 사용자의 요청마다 새로운 프로세스를 생성해야 함. 
- 프로세스를 생성하는 것은 쓰레드를 생성하는 것에 비해 더 많은 시간과 메모리 공간이 필요함. 
- 때문에 많은 수의 사용자 요청을 서비스하기 위해서는 멀티쓰레드가 필요함



### 단점

- 여러 쓰레드가 같은 프로세스 내에서 자원을 공유하면서 작업하기 때문에 동기화, 교착상태와 같은 문제가 발생할 수도 있음



## 03. 쓰레드의 구현과 실행

### Thread 클래스를 상속받는 방법

```java
class MyTread extends Thread {
  public void run() {
    
  }
}
```



### Runnable인터페이스를 구현하는 방법

- Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없어서 이 방법이 일반적임
- 재사용성이 높고 코드의 일관성을 유지할 수 있기 때문에 객체지향적인 방법임

```java
class MyThread implements Runnable {
  public void run() {
    
  }
}
```



## 06. start()와 run()

- 쓰레드 실행시킬 때 run()이 아닌 start()를 호출
- main메서드에서 run()을 호출하는 것은 생성된 쓰레드를 실행시키는 것이 아니라 단순히 클래스에 선언된 메서드를 호출하는 것
- start()는 새로운 쓰레드가 작업을 실행하는데 필요한 호출스택(call stack)을 생성한 다음에 run()을 호출해서 생성된 호출스택에 run()이 첫 번째로 올라가게 함
- 모든 쓰레드는 독립적인 작업을 수행하기 위해 자신만의 호출스택을 필요로 하기때문에, 새로운 쓰레드 생성-실행마다 새로운 호출스택이 생성-쓰레드 종료시 소멸됨

## 07. main메서드

- main쓰레드: main메서드의 작업을 수행하는 것도 쓰레드
- 실행중인 사용자 쓰레드가 하나도 없을 때 프로그램은 종료됨
- 사용자 쓰레드(user thread, non-daemon thread)
- 데몬 쓰레드(daemon thread)



## 08. 싱글쓰레드와 멀티쓰레드

- 싱글쓰레드로 두 개의 작업을 수행한 시간 = 두 개의 쓰레드로 두 개의 작업을 수행한 시간 (거의 같음)
- 쓰레드간의 작업 전환(context switching)에 시간이 소요됨
  - 작업전환을 할 때 현재 진행중인 작업의 상태(다음에 실행해야할 위치(프로그램 카운터)) 등의 정보를 저장하고 읽어 오는 시간이 소요됨
- 쓰레드의 스위칭에 비해 프로세스의 스위칭이 더 많은 정보를 저장해야 하므로 더 많은 시간이 소요됨
- 싱글 코어에서 단순히 CPU만을 사용하는 계산작업이라면 오히려 멀티쓰레드보다 싱글쓰레드로 프로그래밍하는 것이 더 효율적이다



## 11. 쓰레드의 I/O블락킹(blocking)

- 두 쓰레드가 서로 다른 자원을 사용하는 작업의 경우에는 싱글쓰레드 프로세스보다 멀티쓰레드 프로세스가 더 효율적이다.
- 외부기기와의 입출력을 필요로 하는 경우 예) 사용자로부터 데이터를 입력받는 작업, 네트워크로 파일을 주고받는 작업, 프린터로 파일을 출력하는 작업

- I/O블락킹: 쓰레드가 입출력(I/O)처리를 위해 기다리는 것



## 14. 쓰레드의 우선순위

- 우선순위의 값에 따라 쓰레드가 얻는 실행시간이 달라짐
- 쓰레드가 수행하는 작업의 중요도에 따라 쓰레드의 우선순위를 서로 다르게 지정하여 특정 쓰레드가 더 많은 작업시간을 갖도록 할 수 있음
- 쓰레드의 우선순위는 쓰레드를 생성한 쓰레드로부터 상속받음
- 멀티코어에서는 쓰레드의 우선순위에 따른 차이가 거의 없음



## 16. 쓰레드 그룹

- 서로 관련된 쓰레드를 그룹으로 다루기 위한 것
- 쓰레드 그룹에 다른 쓰레드 그룹을 포함 시킬 수 있음
- 보안상의 이유로 도입된 개념
  - 자신이 속한 쓰레드 그룹이나 하위 쓰레드 그룹은 변경 가능, 다른 쓰레드 그룹의 쓰레드를 변경 불가능

```java
Thread(ThreadGroup group, String name)
Thread(ThreadGroup group, Runable target)
```

- 모든 쓰레드는 반드시 쓰레드 그룹에 포함되어 있어야 함
- 자바 어플리케이션 실행되면
  - JVM은 main과 system이라는 쓰레드 그룹 생성
  - JVM운영에 필요한 쓰레드를 생성해서 이 그룹에 포함시킴
- 우리가 생성하는 모든 쓰레드그룹은 main쓰레드 그룹의 하위 쓰레드 그룹이 되며, 그룹 지정 없이 생성한 쓰레드는 자동적으로 main쓰레드 그룹에 속하게 됨



## 18. 데몬 쓰레드(daemon thread)

- 일반쓰레드의 작업을 돕는 보조적인 역할 수행

- 일반 쓰레드가 종료되면 데몬 쓰레드도 강제적으로 자동 종료됨(존재 의미가 없어져서)

- 예) 가비지 컬렉터, 워드프로세서의 자동저장, 화면 자동 갱신 등

- 무한루프와 조건문을 사용해서 실행 후 대기하고 있다가 특정 조건이 만족되면 작업을 수행하고 다시 대기하도록 작성함

  ```java
  public void run() {
    while (true) {
      try {
        Thread.sleep(3*1000);
      } catch(InterruptedException e){}
      if(autoSave) autoSave();
    }
  }
  ```

  

## 20. 쓰레드의 상태

- NEW: 쓰레드가 생성되고 아직 start()가 호출되지 않은 상태
- RUNNABLE: 실행 중 또는 실행 가능한 상태
- BLOCKED: 동기화블럭에 의해서 일시정지된 상태(lock이 풀릴 때까지 기다리는 상태)
- WAITING, TIMED_WAITING: 쓰레드의 작업이 종료되지는 않았지만 실행가능하지 않은(unrunnable) 일시정지상태. TIMED_WAITING은 일시정지시간이 지정된 경우를 의미
- TERMINATED: 쓰레드의 작업이 종료된 상태



### 쓰레드의 생성~소멸 과정

1. 쓰레드를 생성하고 start()를 호출하면 바로 실행되는 것이 아니라 실행대기열에 저장되어 자신의 차례가 될 때까지 기다려야 함. 실행대기열은 큐와 같은 구조로 먼저 실행대기열에 들어온 쓰레드가 먼저 실행됨
2. 실행대기상태에 있다가 자신의 차례가 되면 실행상태가 됨
3. 주어진 실행시간이 다되거나 yeild()를 만나면 다시 실행대기상태가 되고 다음 차례의 쓰레드가 실행상태가 됨
4. 실행 중에 suspend(), sleep(), wait(), join(), I/O block에 의해 일시정지상태가 될 수 있음 
5. 지정된 일시정지시간이 다되거나(time-out), notify(), resume(), interrupt()가 호출되면 일시정지상태를 벗어나 다시 실행대기열에 저장되어 자신의 차례를 기다림
6. 실행을 모두 마치거나 stop()이 호출되면 쓰레드는 소멸됨



## 30. 쓰레드의 동기화(synchronization)

- 멀티쓰레드 프로세스의 경우 여러 쓰레드가 같은 프로세스 내의 자원을 공유해서 작업하기 때문에 서로의 작업에 영향을 주게 됨.
- 한 쓰레드가 특정 작업을 끝마치기 전까지 다른 쓰레드에 의해 방해받지 않도록 하는 것이 필요 -> 임계영역(critical section)과 '잠금(lock)'
  - 공유데이터를 사용하는 코드 영역을 임계영역으로 지정
  - 공유데이터(객체)가 가지고 있는 lock을 획득한 단 하나의 쓰레드만 이 영역 내의 코드를 수행할 수 있게 함
  - 해당 쓰레드가 임계 영역 내의 모든 코드를 수행하고 벗어나서 lock을 반납해야만 다른 쓰레드 수행 가능
- 쓰레드의 동기화: 한 쓰레드가 진행중인 작업을 다른 쓰레드가 간섭하지 못하게 막는 것



## 34. wait()과 notify()

- 특정 쓰레드가 객체의 락을 가진 상태로 오랜 시간을 보내지 않도록 하게 함(보다 효율적인 동기화를 가능하게 함)
- 동기화된 임계 영역의 코드를 수행하다가 작업을 더 이상 진행할 상황이 아니면, 일단 wait()을 호출하여 쓰레드가 락을 반납하고 기다리게 함
- 나중에 작업 진행 가능 상황이 오면 notify()를 호출해서 작업을 중단했던 쓰레드가 다시 락을 얻어 작업 진행
- wait()이 호출되면 실행중이던 쓰레드는 해당 객체의 대기실(waiting pool)에서 통지를 기다림
- 특정 객체에 대한 것이므로 Object클래스에 정의되어 있음
- 동기화 블록 내에서만 사용할 수 있음



### 질문

- 쓰레드와 프로세스의 차이점은 무엇인가요?
- 쓰레드의 장단점에 대해서 설명해주세요.

- 자바에서 쓰레드를 구현하는 방법은 어떤 것이 있나요?
- 쓰레드의 동기화란 무엇이고 필요한 이유는?

- 쓰레드의 우선순위는 무엇이고 어떻게 설정하나요?