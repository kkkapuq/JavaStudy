# Chapter 6

## 객체지향 프로그래밍 I

### 객체지향 언어란?

기존의 프로그래밍 언어에서 새로운 개념이 아닌, 몇가지 규칙과 관계를 형성시켜 발전된 형태의 언어이다. 코드의 재사용성을 높이고, 규칙과 관계로 인한 신뢰성이 높은 프로그래밍이 가능하게 만들어준다.

### 클래스와 객체

클래스는 객체를 만들기 위한 설계도 객체를 정의한 것이며, 객체는 클래스로 생성된 사물 혹은 물체를 말한다. 프로그래밍 관점에서 본다면 오브젝트라고 말할 수 있다.

객체는 크게 속성과 기능으로 나뉜다. TV를 예시로 들어보면 다음과 같다.

| 속성 | 볼륨, 색상, 크기, 길이 등 |
| --- | --- |
| 기능 | 채널 위/아래로, 볼륨 줄이기/키우기 등 |

### 객체와 인스턴스

클래스 → 객체 로 되는 것을 **인스턴스화** 라고 말하며, 이렇게 생성된 객체를 인스턴스 라고 말한다.
객체 == 인스턴스 지만, 객체는 사전적 의미에서 좀 더 포괄적인 의미하고, 인스턴스는 어디서, 어떻게 생성됐는지 좀 더 상세함에 초점을 두고 있다.

### 객체의 생성과 사용과정

1. new를 사용해 참조변수에 메모리를 할당해준다.
2. 참조변수.메서드명 ex) temp.power() 형태로 메서드를 호출하거나, 지역변수의 값을 변경한다.

### 클래스의 정의

변수 : 하나의 데이터를 저장할 수 있는 공간
배열 : 동일한 종류의 여러개의 데이터를 하나의 집합으로 저장할 수 있는 공간
구조체 : 여러 종류, 여러개의 데이터를 하나의 집합으로 저장할 수 있는 공간
클래스 : 구조체 + 함수 가 더해진 것

### 클래스 변수와 인스턴스 변수

클래스 변수 : 클래스 내에서 모든 인스턴스가 공통적으로 사용하는 변수, static을 붙여서 선언
인스턴스 변수 : 클래스 내에서 인스턴스마다 각기 다른 값을 가지는 변수
지역변수 : 메소드 내에 서넝ㄴ되어 그 안에서만 살아있는 변수

클래스 > 인스턴스 > 지역변수 순으로 범위가 확장된다.

### 기본형 매개변수와 참조형 매개변수

기본형 매개변수는 메서드에게 전달된 매개변수의 복사본이 전달된다 (Call By Value)
참조형 매개변수는 인스턴스의 주소가 복사된다 (Call By Reference)

따라서 기본형 매개변수는 원본값에 영향을 미치지 않으며, 참조형은 원본 값에 직접 수정이 가능하다.

### 참조형 반환타입

반환타입도 마찬가지로 참조가 가능하다. 반환타입이 참조형 이라는 것은 메서드가 ‘객체의 주소’를 반환한다는 것을 의미한다.

### 재귀호출

재귀호출은 자기 자신을 호출하는 함수를 말한다. 논리적으로 간결하고, 이해하기 쉬운 코드를 작성할 수 있지만 지속적으로 process stack에 저장하게 된다. 이에 따른 성능저하가 발생할 수 있으니, 리소스를 많이 잡아먹지 않는 코드에만 적용하도록 하자.

### 클래스 메서드와 인스턴스 메서드

클래스 메서드는 비즈니스 로직을 작성하면서, 작업을 해야 하는 중요한 작업과 관계없는 경우에 주로 클래스 메서드로 선언하고, ex) Integer.parseInt()

인스턴스 메서드는 반대로 인스턴스 변수와 관련된 핵심 작업을 수행해야할 때 인스턴스 메서드로 선언한다. 물론 뭐로 하든 동작이야 하겠지만 국룰이라고 보면 된다.

다음 네가지 특징을 명심하도록 하자.

1. 클래스를 설계할 때, 모든 인스턴스에서 공통으로 사용하는 것은 static을 사용해주자
2. 클래스 변수는 인스턴스를 생성하지 않아도 사용이 가능하다.
3. 클래스 메서드 안에선 인스턴스 변수를 사용하지 않는다. (클래스 메서드 내에서 생성이 되지 않았을 수도 있기 때문) 반대로, 인스턴스 멤버간의 호출은 아무런 문제가 없다. 하나의 인스턴스 멤버가 있다는 것은 인스턴스가 이미 생성되어있으며, 다른 인스턴스 멤버들도 모두 존재하기 떄문.
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 고려해보자.

### 오버로딩

오버로딩은 동일한 메서드명에 매개변수, 리턴타입 등을 다르게 설정해주는 것을 말한다.
오버로딩을 통한 이점은 네이밍 관리가 쉬워지기 떄문이다.

가변인자는 메서드명(매개변수1, **자료형… 매개변수명**) 형태로 사용 가능하다. 단, 가변인자임을 알리기 위해 마지막에만 선언 가능하며, 자바 1.5 이상에서 사용 가능하다.

```java
public void temp(int a, int… b)
```

가변인자는 내부적으로 배열을 통해 처리된다. 따라서 메서드가 호출될 때마다 새로운 배열이 할당되므로, 이런 비효율성을 고려한 설계가 필요하다.

```java
static String concatenate(String delim, String... args){
	...
}
static String concatenate(String... args){
	...
}
```

해당 코드도 에러가 발생한다. 오버로딩된 메서드가 구분되지 않았기 때문이다.

따라서 가변인자를 사용한 메서드는 오버로딩을 하지 않는 것이 좋다.

### 생성자

인스턴스가 생성될때 호출되는 **인스턴스 초기화 메서드** 이다.

생성자는 클래스 이름과 같아야 하고, 오버로딩이 가능하며, 리턴값이 없어야 한다.

헷갈리지 말아야 할게, **연산자 new가 인스턴스를 생성해주는 것**이지, 생성자가 인스턴스를 생성해주는 것이 아니다.

클래스가 인스턴스화 되는 과정은 다음과 같다.

1. 연산자 new에 의해 힙메모리에 클래스의 인스턴스가 생성된다.
2. 클래스의 생성자가 호출되어 수행된다.
3. 연산자 new의 결과로, 생성된 클래스 인스턴스의 주소가 반환되어 참조변수에 저장된다.

코드는 다음과 같다.

```java
Card c = new Card();
```

클래스에 별도로 생성자가 작성되어 있지 않다면, 컴파일러가 자동으로 아무 매개변수가 없는 기본 생성자를 생성해준다.

사용자가 별도로 생성자를 작성한 경우엔, 기본 생성자가 생성되지 않아 별도로 작성해줘야 한다.

```java
class Data1 {
	int value;
} // 에러 X

class Data2 {
	int value;
	Data2(int x) {
		value = x;
	}
} // 에러 발생, 기본 생성자가 없다고 뜸 
```

매개변수가 있는 생성자는 생성과 동시에 초기화가 가능하다는 코드의 간결함 측면에서 이점이 있다.

### 생성자에서 다른 생성자 호출하기 (this)

생성자 간에도 서로 호출이 가능하다. 단,

1. 클래스 이름 대신 this 사용
2. 첫 줄에서만 사용 가능

첫 줄에서만 사용 가능한 이유는, 생성자 내에서 초기화 작업 도중에 다른 생성자를 호출하게 되면, 호출된 다른 생성자 내에서도 멤버변수 초기화가 일어나 작업이 무의미해지기 때문.

일반적으로 같은 클래스 내의 생성자들은 관계가 깊은 경우가 많기 떄문에, 서로 호출하여 유기적으로 연결해주면 더 좋은 코드 작성이 가능하다.

### 초기화 블럭

```java
class temp {
	static int[] arr = new int[10];
	static { // 클래스 초기화 블럭
		for(int i = 0; i < arr.length; i++){
			arr[i] = (int)(Math.random()*10) + 1;
		}
	}
	{ // 인스턴스 초기화 블럭
		for(int i = 0; i < arr.length; i++){
			arr[i] = (int)(Math.random()*10) + 1;
		}
	}
}
```

위와 같이 중괄호 안에 초기화 블럭을 생성해, 명시적 초기화만으로는 복잡한 작업을 할 때 한번에 초기화 작업을 진행해줄 수 있다.

## 연습문제

### 6-6

아래의 코드는 인스턴스 메서드를 사용할 때와 메서드를 사용할 때의 차이를 보여 static
주기 위한 것이다 어떤 차이가 있는지 잘 살펴보자.

```java
// static메서드의 사용
System.out.println(Exercise6_6.getDistance(1,1,2,2));
// 인스턴스 메서드의 사용
MyPoint p = new MyPoint(1,1);
System.out.println(p.getDistance(2,2));
```

MyPoint 클래스에 두 점간의 거리를 계산하는 메서드 getInstance를 넣는다면, static 메서드보다는 인스턴스 메서드로 정의하는 것이 더 적합하다.

# 질문

- 166p에서 2번 그림을 보면 메모리에 메서드와 지역변수가 저장이 됩니다. 여기서 메모리의 어떤 영역에 저장 되는걸까요?

```

```

- 173p에서 static이라는 용어가 나옵니다. static과 final의 차이가 뭘까요?

```

```

- 184p에서 할당된 메모리 공간은 반환되어 비워진다고 합니다. 여기서 gc가 개입하게 되는데요, gc의 개념과 동작원리에 대해서 설명 부탁드립니다.

```

```

- 185p에서 기본형 매개변수와 참조형 매개변수가 나옵니다. 자바에서 참조 하면 떠오르는게 값에 의한 호출과 참조에 의한 호출이 있습니다. 차이점이 뭘까요?

```

```

- 오버라이딩과 오버로딩의 차이점은 뭘까요?

```java

```

- 가변인자는 실무에서 많이 사용할까요?

```java

```

- 6-6 연습문제에서, 두 점간의 거리를 구하는거라면 그냥 static메서드로 선언하고 두 점 입력받는게 더 간단하지 않을까요?