# 상속

## 상속의 정의와 장점

상속은, 기존 클래스를 재사용하여 새로운 클래스를 작성하는 것이다. 이 때, 기존 클래스의 요소들이 모두 넘어오기 때문에 중복된 코드를 피하고, 유지보수성을 향상시킨다. 특징은 다음과 같다.

1. 생성자와 초기화 블럭은 넘어오지 않는다.
2. 자식 클래스의 멤버 개수는 부모 클래스보다 많거나 같다.

## toString() 오버라이딩

예제 7-3에서 toString()을 오버라이딩했고, 이를 명시적으로 사용하지 않아도 객체 c를 호출하는데 바로 호출됐다. 이처럼 참조변수의 출력이나, 문자열의 결합에는 toString()이 자동으로 호출되어 참조변수를 문자열로 치환한 후 처리한다.

```java
System.out.println(c);
System.out.println(c.toString()); //동일한 결과 노출
```

## Object클래스

모든 자바 객체들은 Object 클래스를 상속받는다. 이유는 다음과 같다.

1. 모든 클래스가 객체를 암시적으로 확장하게 하면서, 자바가 모든 객체를 일관된 방식으로 처리하고, 통합된 인터페이스를 제공하기 위함이다.
2. toString(), equals() 와 같은 공용 메서드를 제공하기 위함이다.
3. 모든 클래스가 Object의 성질을 갖는다는 것은 자바의 다형성과 큰 연관이 있다. 따라서 모든 유형의 객체와 함께 동작할 수 있는 일반적인 코드를 작성할 수 있다.
4. gc와도 연관이 있다. 모든 Object들은 gc의 대상이 되고, Object들은 gc가 수행되기 전에 gc작업을 정리하기 위해 하위클래스에서 재정의할 수 있는 finalize() 를 제공한다.
5. 자바의 리플렉션 API는 런타임에 클래스를 검사하고, 조작할 수 있는 기능을 제공한다. getClass()와 같은 메서드를 제공하기 때문에, 이러한 리플렉션 작업에서 중심적인 역할을 수행한다.

# 오버라이딩

## 오버라이딩의 정의와 조건

오버라이딩은 함수를 재정의 하는것을 말한다. 조건은 다음과 같다.

1. 이름, 매개변수, 반환 타입이 같아야 한다.
2. 자식 클래스에서 진행하는 예외처리는 부모 클래스보다 적거나 같아야 한다.
3. 접근제어자는 부모 클래스보다 좁은 범위로 처리할 수 없다.
4. 인스턴스 메서드를 static메서드로, 또는 그 반대로 변경할 수 없다.

## super, super()

super는 this와 완전하게 동일한 기능을 하되, 부모 클래스의 객체를 대신해서 나타내는 참조변수이다. super() 또한 this()와 동일한 부모클래스의 생성자를 의미하는데, 알아둬야 할 점이 있다.

예제 7-8에 의하면, Point 메서드에서 상속을 하지 않은 상황이면 super()를 통해 최상위 클래스인 Object를 호출한다. 따라서 Object의 기본 생성자인 Object()가 인스턴스화 되는것과 동일하다.

# 제어자

## 제어자의 구분과 종류

제어자는 클래스 앞에 선언되어 부가적인 의미를 부여하는 예약어이다.
크게 접근제어자와 그 외의 제어자로 나뉜다.

| 접근 제어자 | 그 외 |
| --- | --- |
| public, protected, default, private | staitc, final, syncronized, abstract.. |

접근 제어자별 특징은 다음과 같다.

- public : 모든 곳에서 접근 가능
- protected : 패키지 안에서, 다른 패키지의 파생클래스에서 사용가능
- default : 동일한 패키지 내부에서만 사용 가능
- private : 클래스 내부에서만 사용 가능

제어자를 조합해서 사용할 땐 다음 사항을 주의하자.

1. 메서드에 static과 abstract를 같이 쓸 수 없다.
static이 생성되는 시점에 abstract 대상 메서드가 생성되지 않을 수 있기 때문이다.
2. 클래스에 abstract와 final을 동시에 쓸 수 없다.
클래스에 선언되는 final은 변할 수 없다는 건데, abstract를 사용하는건 상속을 통해 완성되어야 하는 의미이므로 모순이 발생한다.
3. abstract메서드의 접근 제어자가 private일 수 없다.
마찬가지로 상속을 통해서 완성되는 메서드기 때문에, 자식 클래스에서 내부 멤버에 접근할 수 없기 때문이다.
4. 메서드에 private과 final을 같이 사용할 필요는 없다.
둘 중 하나만 써도 충분하다.

# 다형성

## 다형성의 정의

여러 형태를 가질 수 있는 능력으로, 부모 클래스 타입의 참조변수로 자식 클래스의 인스턴스를 참조할 수 있다 라는 뜻이다.

```java
List<Integer> list = new ArrayList<Integer>();
```

이 코드 한방으로 끝. 이렇게 하는 이유는 만약 ArrayList가 아닌 LinkedList로 바뀌어야 한다면, ArrayList를 LinkedList로 바꿔주기만 하면 된다.

이처럼 다형성을 통해 코드의 결합도를 낮출 수 있다.

**중요한 점**은, 자식 클래스 타입의 참조변수는 부모클래스의 인스턴스를 참조할 수 없다.

```java
ArrayList<Integer> list = new List<Integer>();
```

이게 안된다는 뜻. 왜냐하면 자식 클래스가 가지고 있는 멤버는 기본적으로 부모 클래스보다 많거나 같기 때문에 이를 허용하지 않는다.

## 참조변수의 형변환

기본형 변수와 마찬가지로 참조변수도 형변환이 가능하다. 단,

1. 자손타입의 참조변수를 조상타입의 참조변수로 (업캐스팅)
2. 조상타입의 참조변수를 자손타입의 참조변수로 (다운캐스팅)

만 형변환이 가능하다.

업캐스팅은 생략이 가능하고, 다운캐스팅은 불가능하다. 부모 클래스가 갖고있는 멤버보다 자식 클래스의 멤버 개수가 많을 수 있기 때문이다.

형변환을 통해 변환된 **참조변수는 타입을 변환하는 것**이지 인스턴스 자체가 **변환되는 것이 아니기**에, **인스턴스**에는 아무런 영향을 미치지 않는다. 참조하고 있는 인스턴스에서 사용 가능 멤버의 개수를 조절하는 것이다.

## 참조변수와 인스턴스의 연결

조상클래스와 자손클래스에 동일한 멤버가 있다면

**조상 타입**의 참조변수를 사용했을 때는 **조상클래스**에 선언된 멤버변수가,
**자손 타입**의 참조변수를 사용했을 때는 **자손클래스**에 선언된 멤버변수가 사용된다.

멤버와 다르게 **메서드는 실제 인스턴스의 메서드**가 사용된다.

# 추상클래스와 인터페이스

| 추상클래스 | 인터페이스 |
| --- | --- |
| 미완성 설계도의 개념, 부모 클래스의 기능을 이어받거나, 확장하기 위함 | 구현체들이 동일한 동작을 하는 것을 보장하기 위함 |
| 단일상속만 가능 | 다중상속 가능 |

## 추상클래스

추상클래스는 미완성 설계도의 개념이다. 미완성으로 남겨놓는 이유는, 부모클래스로부터 전달받은 메서드의 내용이 클래스에 따라 달라질 수 있기 때문이다.

따라서 추상클래스를 상속받는 자식 클래스는 부모 클래스의 추상메서드를 상황에 맞게 적절히 구현해주어야 한다.

## 추상화와 구체화

추상화 : 클래스의 공통요소가 많아지고, 공통의 조상을 만드는 작업
구체화 : 상속을 통해 클래스를 세분화 하고, 구현하는 작업

추상클래스를 사용하는 이유는, 설계된 클래스의 의도와 환경에 알맞게 그때그때 맞춰서 구현하라는 것을 강요하기 위함이다.
만약 부모 클래스에 추상클래스가 아니라 모든 로직이 설계되있다면, 해당 클래스를 상속받는 자식클래스는 해당 메서드들이 온전히 구현된 것으로 인식하고, 클래스에 맞도록 구현하지 않을 수도 있기 때문이다.

## 인터페이스

추상화가 미완성된 설계도라면, 인터페이스는 구현된 것이 없는 기본 설계도라고 보면 된다.
인터페이스로 구현된 객체들이 동일한 동작을 하는 것을 보장해주는 역할을 한다.

인터페이스의 모든 멤버변수는 public static final, 메서드는 public abstract 이어야 하며, 생략이 가능하다. 자바 8 이후로는 static 메서드와 default 메서드는 예외로 추가가 가능하다.

## 인터페이스의 다중 상속

기본적으로 인터페이스는 다중상속을 허용하고 있으나, 실질적으로 사용되지는 않는다. 왜냐하면 다중 상속이 됐을 때, 메서드명이 동일하다면 어떤 것을 써야할 지 모호해지기 때문이다.

이러한 단점 때문에 자바가 단일상속을 선택한 이유이기도 하고, 그렇다고 인터페이스가 다중상속을 위해서 존재한다 라는 의미 또한 틀리다고 볼 수 있다.

만약 두 개의 클래스로부터 다중 상속을 받아야 한다면, **비중이 높은 부모 클래스를 선택**하고, 나머지 하나는 멤버변수로 포함시키는 방식으로 처리하거나, 어느 한쪽의 **필요한 부분을 뽑아서 인터페이스로** 만든 다음 구현하도록 한다.

## 인터페이스의 다형성

조상 클래스 타입의 참조변수로 자식 클래스 인스턴스를 참조할 수 있다고 했다.

마찬가지로, 인터페이스 또한 인터페이스 타입으로 해당 인터페이스를 구현한 클래스를 참조할 수 있다. (형변환도 가능)

```java
Fightable f = new Fighter();
```

이렇게 했을 때, fightable의 리턴타입이 인터페이스라면, 이는 곧 해당 인터페이스를 구현한 클래스의 인스턴스를 반환하는 것을 의미한다.

## 인터페이스의 장점

1. 독립적인 개발이 가능해진다.
클래스의 선언과 구현을 분리시킬 수 있기 때문에, 실제 구현에 독립적인 프로그램을 작성하는 것이 가능하다.
2. 표준화가 가능하다.
프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음, 개발자들에게 인터페이스에 맞춰 개발하도록 하면 보다 일관되고 정형화된 프로그램의 개발이 가능하다.
3. 서로 관계없는 클래스들에게 관계를 맺어줄 수 있다.
아무런 관계도 없는 클래스들에게 공통의 인터페이스를 구현하게 하면 관계를 맺어줄 수 있다.
4. 개발 시간을 단축시킬 수 있다.
메서드를 호출하는 쪽은 선언부만 알면 되서 따로 개발하고, 그동안 다른 한쪽은 구현부를 작성할 수 있다.

## 인터페이스의 이해

- 클래스는 인터페이스를 매개변수로 받아서, 인터페이스를 구현한 클래스의 인스턴스를 동적으로 받아야 한다 ex) Thread의 생성자인 Thread(Runnable target)
- 매개변수로 주는 방법도 있지만, 제 3의 클래스를 통해 인터페이스를 구현한 클래스의 인스턴스를 가져오는 방법도 있다. ex) JDBC.DriverManager 클래스

## 디폴트 메서드와 static 메서드

인터페이스의 메서드들은 모두 추상메서드로 정의되고, 그에 따라 인터페이스를 구현한 클래스에서 해당 메서드를 구현해야 한다. 문제는 나중에 인터페이스에 새로운 메서드가 추가될 때인데, 이 때 사용되는 것이 디폴트 메서드이다.

디폴트 메서드가 기존의 메서드와 이름이 같아 충돌이 되는 경우가 있는데, 이 경우는 그냥 **필요한 쪽의 메서드와 같은 내용**으로 오버라이딩 해주면 그만이다.

static 메서드는 일반적인 static개념과 동일하게 인스턴스와 관계없는 독립적인 메서드이다.
자바의 규칙성 통일을 위해, 모든 인터페이스의 메서드는 추상 메서드여야 한다는 규칙에 예외를 두지 않았고, 이 때문에 static메서드는 별도의 클래스에 따로 두어야 했다.

대표적인 케이스가 Collection 인터페이스인데, 여기 있는 메서드들이 인터페이스에는 추상 메서드만 선언 가능하다는 규칙 때문에 해당 인터페이스에 다 몰아둔 것이다.

# 내부 클래스

## 내부 클래스의 정의와 특징

내부클래스는 일반적인 클래스의 특징을 모두 가지고 있고, 클래스 내부에 추가로 정의되는 클래스를 말한다. 실무에서 자주 쓸 일은 없으니 그냥 기본적인 내용과 특징을 이해하는 정도로만 하자.

종류는 다음과 같다.

- 인스턴스 클래스 : 클래스의 멤버변수 위치에 선언, 일반적인 인스턴스 변수와 동일
- static 클래스 : 클래스의 멤버변수 위치에 선언, 일반적인 static 변수와 동일
- 지역 클래스 : 외부 클래스의 메서드나 초기화 블럭 안에 선언, 선언된 영역에서만 사용가능
- 익명 클래스 : 클래스의 선언과 객체의 생성을 동시에 하는 익명 클래스 (익명함수랑 비슷)

제어자 또한 동일하게 적용된다.

```java
package Chapter7.Practice;
class Practice7_25_ParserTest {
    public static void main(String[] args) {
        Parseable parser = ParserManager.getParser("XML");
        parser.parse("document.xml");
        parser = ParserManager.getParser("HTML");
        parser.parse("document2.html");
    }
    class XMLParser implements Parseable {
        public void parse(String fileName) {
            System.out.println(fileName + "- XML parsing completed.");
        }
    }
    class HTMLParser implements Parseable {
        public void parse(String fileName) {
            System.out.println(fileName + "- HTML parsing completed.");
        }
    }
    interface Parseable {
        // 구문 분석작업 수행
        void parse(String fileName);
    }
    class ParserManager {
        public static Parseable getParser(String type) {
            if (type.equals("XML")) {
                // 여기 에러
                return new XMLParser();
            } else {
                // 여기 에러
                Parseable p = new HTMLParser();
                return p;
                // return new HTMLParser() 와 동일하다.
            }
        }
    }
}
```

해당 구문에서 에러가 발생하는 이유는, 내부 클래스에서 선언된 getParser 메서드가 static으로 선언됐기 때문에, 다른 내부클래스인 HTMLParser나 XMLParser를 참조하려면 똑같이 static이어야 한다.

# 질문

- 예제 7-3에 toString() 메서드를 오버라이드 해서 사용했습니다. toString 메서드는 임의로 호출하지 않았는데 왜 출력이 되는걸까요?

```java

```

- 자바는 상속 시에 단일상속을 씁니다. 단일상속과 다중상속의 장단점이 어떻게 될까요?

```
기본적으로, 다중상속은 하나의 객체에 여러 클래스를 상속할 수 있다는 장점이 있습니다.
하지만 상속받은 클래스에 동일한 메서드가 있으면 모호함이 발생합니다.
또한 하나의 클래스를 간접적으로 두 번 이상 상속받을 가능성이 있습니다.

반대로 단일상속을 하나의 클래스만 상속할 수 있기 때문에, 복잡도가 낮아지고 앞서 언급한 모호함을 해결할 수 있습니다.
```

- 자바의 모든 객체는 Object클래스를 상속받습니다. 이유가 뭘까요?

```java

```

- 어떤 경우에 상속(abstract)을 쓰고, 어떤 경우에 구현(implements)을 사용할까요?

```java

```

- 자바 8 이후로는 인터페이스 내에 static과 default 메서드를 추가할 수 있습니다. 이를 설명해주세요.

```

```