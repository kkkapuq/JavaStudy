# Chapter 7. 상속

## 01. 상속 (222p)

- 상속: 기존의 클래스를 재사용하여 새로운 클래스 작성

- 상속의 장점

  - 상속을 통해서 클래스 작성 시, 작성하면 보다 적은 양의 코드로 새로운 클래스를 작성 가능
  - 코드를 공통적으로 관리하여 코드의 추가 및 변경 매우 용이
  - 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 기여

- 상속 구현 방법

  - 새로 작성하고자 하는 클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 키워드 'extends'와 함께 써준다

    ```java
    class Parent {}
    class Child extends Parent {

    }
    ```

- 조상 클래스: 상속해주는 클래스

- 자손 클래스: 상속 받는 클래스

- 자손 클래스는 **조상 클래스의 모든 멤버를 상속**받는다. (단, 생성자와 초기화 블럭은 상속되지 않는다.)

  - Child클래스에 새로운 코드가 추가되어도 조상인 Parent클래스는 아무런 영향도 받지 않음

- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.

  - 조상 클래스의 모든 멤버를 상속 받기 때문

## 03. 클래스 간의 관계 - 포함관계

- 클래스 재사용 방법: 상속, 포함 관계 형성

- 포함: 클래스 간의 포함관계를 맺어 주는 것 -> 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것

  ```java
  class Circle {
    int x;
    int y;
    int r;
  }

  class Point {
    int x;
    int y;
  }

  // Point클래스를 재사용해서 Circle 클래스 작성
  class Circle {
    Point c = new Point(); // 원점
    int r;
  }
  ```

- 하나의 거대 클래스 작성하는 것보다, 단위별로 여러 개의 클래스 작성 후 포함관계로 재사용하는 것이 보다 간결함

## 04. 클래스 간의 관계 결정하기

- 상속 or 포함관계 결정
  - ~은 ~이다(is-a) -> 상속 관계
  - ~은 ~을 가지고 있다(has-a) -> 포함 관계

## 05. 단일 상속(Single Inheritance)

- 자바에서는 단일 상속만 허용 (C++에서는 다중 상속 허용)

  - 둘 이상의 클래스로부터 상속 받을 수 없음

  - 다중 상속 허용 시, 복합적 기능을 가진 클래스를 쉽게 작성할 수 있음. but 클래스 간의 관계가 매우 복잡해지고 서로 다른 클래스로부터 상속받은 멤버간의 이름이 같은 경우 구별할 수 없음
  - 단일 상속: 클래스 간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있게 만들어 줌

## 06. Object클래스 - 모든 클래스의 조상

- Object클래스: 모든 클래스 상속계층도의 최상위에 있는 조상클래스

  - 다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동적으로 Object클래스로부터 상속 받게 함

## 07. 오버라이딩(overriding)

- 오버라이딩: 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것

  ```java
  class Point {
  int x;
  int y;

  String getLocation() {
    return "x :" + x + ", y :"+ y; // 한 점의 x,y 좌표를 문자열로 반환
  }
  }

  class Point3D extends Point { // 3차원 좌표계의 한 점을 표현
    int z;
    String getLocation() { // 오버라이딩
      return "x :" + x + ", y:"+ y + ", z :" + z; // z축의 좌표값도 포함하여 반환
    }
  }
  ```

## 08. 오버라이딩의 조건

- 메서드의 선언부(메서드 이름, 매개변수, 반환타입) 조상의 것과 완전히 일치해야 함
- 접근 제어자(access modifier)와 예외(exception)는 제한된 조건 하에서만 다르게 변경 가능
  - 접근 제어자를 조상클래스의 메서드보다 좁은 범위로 변경할 수 없다
    - (넓은 접근 범위) public, protected, (default), private (좁은 접근 범위)
  - 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다

## 09. 오버로딩 vs 오버라이딩

- 오버로딩: 기존에 없는 새로운 메서드 추가(정의)
- 오버라이딩: 조상으로부터 상속받은 메서드의 내용을 변경하는 것

  ```java
  class Parent {
    void parentMethod() {}
  }
  class Child extends Parent {
    void parentMethod() {} // 오버라이딩
    void parentMethod(int i) {} // 오버로딩

    void childMethod() {}
    void childMethod(int i) {} // 오버로딩
    void childMethod() {} // 에러, 중복정의
  }
  ```

## 10. 참조변수 super

- super: 자손 클래스에서 조상 클래스로부터 **상속받은 멤버**를 참조하는데 사용되는 참조변수

  - 멤버변수와 지역변수의 이름이 같을 때 this를 붙여서 구별
  - 상속받은 멤버와 자신의 멤버와 이름이 같을 때 super로 구별 가능

  ```java
  class Ex7_2 {
    public static void main(String args[]) {
      Child c = new Child();
      c.method();
    }
  }

  class Parent { int x = 10; /* super.x */ }

  class Child extends Parent {
    int x = 20; // this.x

    void method(){
      System.out.println("x=" + x);
      System.out.println("this.X=" + this.x);
      System.out.println("super.x="+ super.x);
    }
  }

  // x=20
  // this.x=20
  // super.x=10
  ```

  - 모든 인스턴스 메서드에는 this와 super가 지역변수로 존재 -> 자신이 속한 인스턴스의 주소가 자동으로 저장됨

## 11. super() - 조상의 생성자

- super(): 조상의 생성자 호출
- this(): 같은 클래스의 다른 생성자 호출

  ```java
  Point3D(int x, int y, int z) {
    super(x, y); //조상클래스의 생성자 Point(int x, int y)를 호출
    this.z = z; // 자신의 멤버를 초기화
  }
  ```

- 생성자는 상속되지 않음

## 12. 패키지(package)

- 패키지: 클래스의 묶음

  - 패키지에는 클래스 또는 인터페이스를 포함시킬 수 있음
  - 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리 가능
  - 같은 이름의 클래스 일지라도 서로 다른 패키지에 존재하는 것이 가능
    - 자신만의 패키지 체계를 유지함으로써 다른 개발자가 개발한 클래스 라이브러리의 클래스와 이름 충돌 방지

- 클래스의 실제 이름은 패키지명을 포함한 것 (ex: java.lang.String)
- 클래스가 물리적으로 하나의 클래스파일(class)인 것과 같이 패키지는 **물리적으로 하나의 디렉토리임**
  - 어떤 패키지에 속한 클래스는 해당 디렉토리에 존재하는 클래스파일 (클래스 이름.class)이어야 함

## 13. 패키지의 선언

- 클래스나 소스파일(.java)의 맨 위에 `package 패키지명;` 작성

  - 반드시 소스파일에서 주석과 공백을 제외한 첫 번째 문장이어야 함
  - 하나의 소스파일에 단 한 번만 선언
  - 패키지명 대소문자 모두 허용하나 클래스명과의 구분을 위해 소문자 원칙

- 자바에서 기본적으로 제공하는 '이름 없는 패키지(unnamed package)'가 있어서 소스파일에 자신이 속할 패키지 선언하지 않으면 자동으로 속함

## 14. 클래스 패스(classpath)

- 패키지의 루트 디렉토리를 클래스패스(classpath)에 포함시켜야 함
- 클래스패스를 지정해 주지 않으면 기본적으로 현재 디렉토리(,)가 클래스패스로 지정됨

## 15. import문

- 클래스의 코드를 작성하기 전에 import문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면 소스코드에 사용되는 클래스이름에서 패키지명은 생략 가능

  ```java
  import 패키지명.클래스명;
  import 패키지명.*; // 지정된 패키지에 속하는 모든 클래스를 패키지명 없이 사용
  // 실행 시 성능상의 차이 전혀 없음
  ```

## 16. static import문

- static import문을 사용하면 static멤버를 호출할 때 클래스 이름을 생략 가능

  ```java
  import static java.lang.Integer.*; // Integer클래스의 모든 static 메서드
  import static java.lang.Math.random; // Math.random()만. 괄호 안붙임.
  import static java.lang.System.out; // System.out out만으로 참조가능

  // System.out.println(Math.random());
  out.println(random());
  ```

## 17. 제어자(modifier)

- 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여
- 접근 제어자: public, protected, (default), private
- 그 외의 제어자: static, final, abstract, native, transient, synchronized, volatile, strictfp
- 클래스나 멤버변수와 메서드에 주로 사용
- 하나의 대상에 대해서 여러 제어자 조합 가능
- 단, 접근 제어자는 한 번에 네 가지 중 하나만 선택해서 사용 가능

## 18. static - 클래스의, 공통적인 (240p)

- 인스턴스 변수는 하나의 클래스로 부터 생성되었더라도 각기 다른 값을 유지하지만, 클래스 변수(static멤버변수)는 인스턴스에 관계없이 같은 값을 가짐
  - 하나의 변수를 모든 인스턴스가 공유하기 때문
- static이 붙은 멤버변수와 메서드, 그리고 초기화 블럭은 인스턴스가 아닌 클래스에 관계된 것이기 때문에 인스턴스를 생성하지 않고도 사용할 수 있음
- static이 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭
  - 멤버변수
    - 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다.
    - 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.
    - 클래스가 메모리에 로드될 때 생성된다.
  - 메서드
    - 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
    - static 메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다.

## 19. final - 마지막의, 변경될 수 없는 (241p)

- final: 거의 모든 대상에 사용될 수 있음
- final이 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수
  - 클래스: 변경될 수 없는 클래스, 확장될 수 없는 클래스가 됨, final로 지정된 클래스는 다른 클래스의 조상이 될 수 없음
  - 메서드: 변경될 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해
    재정의 될 수 없음
  - 멤버변수 & 지역변수: 변수 앞에 final이 붙으면 값을 변경할 수 없는 상수가 됨

## 20. abstract - 추상의, 미완성의

- abstract: 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용
- abstract가 사용될 수 있는 곳 - 클래스, 메서드
  - 클래스: 클래스 내에 추상 메서드가 선언되어 있음을 의미
  - 메서드: 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알림
- 추상 클래스는 **아직 완성되지 않은 메서드가 존재**하는 '미완성 설계도'이므로 인스턴스를 생성할 수 없음

## 21. 접근 제어자(access modifier)

- 접근 제어자: 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할
- public: 접근 제한 없음 (접근범위 가장 넓음)
- protected: 같은 패키지 내, 다른 패키지의 자손클래스에서 접근 가능
  - 패키지에 관계없이 상속관계에 있는 자손클래스에서 접근할 수 있도록 하는 것이 제한목적
- (default): 같은 패키지 내에서만 접근 가능
- private: 같은 클래스 내에서만 접근 가능

## 22. 캡슐화와 접근 제어자

- 접근제어자 사용 이유
  - 클래스의 내부에 선언된 데이터를 보호하기 위해 접근 제어자 사용
  - 캡슐화(encapsulation) (=데이터 감추기): 데이터가 유효한 값을 유지하도록, 외부에서 함부로 변경하지 못하도록 하기 위해서 외부로부터의 접근 제한, 내부적으로만 사용되는 부분을 감추기 위해
- 상속을 통해 확장될 것이 예상되는 클래스라면 멤버에 접근 제한을 주되 자손클래스에서 접근하는 것이 가능하도록 하기 위해 private대신 protected를 사용
- get멤버변수이름: 멤버변수의 값을 읽는 메서드
- set멤버변수이름: 멤버변수의 값을 변경하는 메서드

## 23. 다형성(polymorphism)

- 여러 가지 형태를 가질 수 있는 능력
- 자바에서 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함
- 조상클래스 타입의 참조변수로 자손클래스의 인스턴스 참조 가능
- 인스턴스 타입과 일치하는 타입의 참조변수만 사용
- 서로 상속관계에 있을 경우, 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조하도록 하는 것도 가능
  ```java
  SmartTv s = new SmartTv(); // 참조변수와 인스턴스 타입 일치
  Tv t = new SmartTv(); // 타입 불일치, 조상 타입의 참조변수로 자손 인스턴스를 참조
  ```
- 자손타입의 참조변수로 조상타입의 인스턴스 참조 불가능

## 24. 참조변수의 형변환

- 참조변수의 형변환: 서로 상속관계에 있는 클래스 사이에서만 가능
  - 자손타입의 참조변수 -> 조상타입의 참조변수 (Object클래스타입)
  - 조상타입의 참조변수 -> 자손타입의 참조변수
- 기본형의 형변환과 달리 참조형의 형변환은 변수에 저장된 값(주소값)이 변환되는 것이 아님
  - 참조형의 형변환은 사용할 수 있는 멤버 개수를 조절하기 위한 것
  - 참조변수가 가리키는 인스턴스의 타입이 무엇인지 먼저 확인하는 것이 중요

## 26. instanceof 연산자

- 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용
- 값 null 참조변수에 대해 instanceof 연산을 수행하면 false

```java
void dowork(Car c) {
  if (c instanceof FireEngine) { // 1. 형변환이 가능한지 확인
    FireEngine fe = (FireEngine); // 2. 형변환
    fe.water();
  }
}
```

- 어떤 타입에 대한 instanceof 연산의 결과가 true라는 것은 검사한 타입으로 **형변환이 가능하다**는 뜻

## 27. 매개변수의 다형성

- 참조변수의 다형적인 특징은 메서드의 매개변수에도 적용됨

## 29. 여러 종류의 객체를 배열로 다루기

- 조상타입의 참조변수 배열을 사용하면, 공통의 조상을 가진 서로 다른 종류의 객체를
  배열로 묶어서 다룰 수 있다.
- 또는 묶어서 다루고싶은 객체들의 상속관계를 따져서 가장 가까운 공통조상 클래스 타입의 참조변수 배열을 생성해서 객체들을 저장하면 된다.
- Vector클래스: 내부적으로 Object타입의 배열을 가지고 있어서, 이 배열에 객체를 추가하거나 제거할 수 있게 작성되어 있음

  - 배열의 크기를 알아서 관리해주기 때문에 저장할 인스턴스 개수 고려하지 않아도 됨
  - 동적으로 크기가 관리되는 객체배열

  ```java
  public class Vector extends AbstractList implements List, Cloneable, java.io.Serializable {
    protected Object elementData[];
  }
  ```

## 31. 추상 클래스(abstract class)

- 클래스가 미완성이라는 것은 멤버 개수에 관련 x, 추상메서드(미완성 메서드)를 포함하고 있다는 뜻
- 추상클래스: 키워드 'abstract' 인스턴스 생성 불가, 상속을 통해서 자손클래스에 의해서만 완성될 수 있음
  - 새로운 클래스 작성하는 데에 있어 바탕이 되는 조상클래스
  - 추상클래스는 추상클래스를 포함하고 있다는 것 이외에 일반 클래스와 같음 (생성자 있음, 멤버변수, 메서드 존재 가능)

## 32. 추상 메서드(abstract method)

- 추상메서드: 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것
- 상속받는 클래스에 따라 메서드의 내용이 달라질 수 있기 때문에 미완성으로 남겨 놓음
  ```java
  // 주석을 통해 어떤 기능을 수행할 목적으로 작성했는지 설명
  abstract 리턴타입 메서드이름();
  ```
- 추상클래스로부터 상속받는 자손클래스는 오버라이딩을 통해 조상인 추상클래스의 추상메서드를 모두 구현해주어야 함
- 조상으로부터 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자손클래스 역시 추상클래스로 지정해 주어야 함

## 33. 추상클래스의 작성

- 상속계층도를 따라 내려갈수록 클래스는 점점 기능이 추가되어 구체화의 정도가 심해짐
- 상속계층도를 따라 올라갈수록 클래스는 추상화의 정도가 심해짐

## 35. 인터페이스(interface)

- 일종의 추상클래스
- 인터페이스는 추상클래스처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아서 추상클래스와 달리 **몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없음**

```java
interface 인터페이스이름 {
  public static final 타입 상수이름 = 값;
  public abstract 메서드이름(매개변수목록);
}
```

- interface에도 클래스처럼 접근제어자로 public or default만 사용 가능
- 인터페이스 멤버 제약 사항
  - 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.
  - 모든 메서드는 public abstract (접근제어자) 이어야 하며, 이를 생략할 수 있다. 단, static 메서드와 디폴트 메서드는 예외(JDK1.8부터)

## 36. 인터페이스의 상속

- 인터페이스는 인터페이스로부터만 상속받을 수 있음
  - 클래스와 달리 Object 클래스와 같은 최고 조상이 없음
  - 자손 인터페이스는 조상 인터페이스에 정의된 멤버 모두 상속 받음
- 클래스와 달리 다중상속 가능

## 37. 인터페이스의 구현

- 인터페이스는 구현한다는 의미의 키워드 'implements'를 사용

## 38. 인터페이스를 이용한 다형성

- 클래스처럼 인터페이스 역시 이를 구현한 클래스의 조상이라 할 수 있으므로 해당 인터페이스 타입의 참조변수로 이를 구현한 **클래스의 인스턴스를 참조**할 수 있음
- 인터페이스 타입으로의 형변환도 가능
- 인터페이스는 메서드의 매개변수의 타입으로도 사용될 수 있음

  ```java
  void attack(Fightable f) {

  }
  ```

- 메서드의 리턴타입으로 인터페이스 지정 가능
  - **리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미**
  ```java
  Fightable method() {
    Fighter f = new Fighter(); //
    return f;                 // => return new Fighter();
  }
  ```

## 39. 인터페이스의 장점

- 개발시간을 단축시킬 수 있다.
- 표준화가 가능하다.
- 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
- 독립적인 프로그래밍이 가능하다.
  - 클래스의 선언과 구현을 분리시킬 수 있기 때문에 한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않음

## 40. 디폴트 메서드와 static메서드

- JDK1.8부터 디폴트 메서드와 static메서드도 인터페이스에 선언 가능
  - static메서드는 인스턴스와 관계가 없는 독립적인 메서드
- 디폴트 메서드: 추상 메서드의 기본적인 구현을 제공하는 메서드
  - 추상 메서드가 아니기 대문에 디폴트 메서드가 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 됨
  - 접근 제어자: public (생략 가능)
- 디폴트메서드와 기존 메서드 이름 중복으로 충돌 시 해결 규칙
  - 여러 인터페이스의 디폴트 메서드 간의 충돌
    - 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩 해야함
  - 디폴트 메서드와 조상 클래스의 메서드 간의 충돌
    - 조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시됨

## 42. 내부 클래스 (inner class)

- 내부 클래스: 클래스 내에 선언된 클래스
- 내부 클래스의 장점
  - 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있음
  - 코드의 복잡성을 줄일 수 있음(캡슐화)
- 내부 클래스는 외부 클래스를 제외하고는 다른 클래스에서 잘 사용되지 않는 것이어야 함

## 43. 내부 클래스의 종류와 특징

- 내부 클래스 (변수의 선언위치에 따라 구분)
  - 인스턴스 클래스: 외부 클래스의 멤버변수 선언위치에 선언, 외부 클래스의 인스턴스멤버처럼 다루어짐. 주로 외부 클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언됨
  - static 클래스: 외부 클래스의 멤버변수 선언위치에 선언, 외부 클래스의 static멤버처럼 다루어짐. 주로 외부 클래스의 static멤버, 특히 static 메서드에서 사용될 목적으로 선언됨
  - 지역 클래스 (local class): 외부 클래스의 메서드나 초기화블럭 안에 선언하며 선언된 영역 내부에서만 사용될 수 있다.
  - 익명 클래스: 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)

## 44. 내부 클래스의 선언

- 각 내부 클래스의 선언 위치에 따라 같은 선언위치의 변수와 동일한 유효범위(scope)와 접근성(accessibility)을 가짐

## 45. 내부 클래스의 제어자와 접근성

- 내부 클래스는 외부 클래스의 멤버변수와 같이 간주되고, 인스턴스 멤버와 static 멤버 간의 규칙이 내부 클래스에도 똑같이 적용됨
- 내부 클래스도 클래스이기 때문에 abstract final과 같은 제어자를 사용할 수 있음
  - 스태틱 클래스만 static 멤버를 가질 수 있음
  - 내부 클래스에 static 변수 선언 시 스태틱 클래스로 선언해야 함
  - final static 동시에 붙은 변수는 상수이므로 모든 내부 클래스에서 정의 가능
- 멤버변수들처럼 private, protected과 접근제어자도 사용 가능
- 인스턴스클래스는 외부 클래스의 인스턴스멤버를 객체생성 없이 바로 사용할 수 있지만, 스태틱 클래스는 외부 클래스의 인스턴스멤버를 객체생성 없이 사용할 수 없다.

## 51. 익명 클래스 (anonymous class)

- 클래스의 선언과 객체의 생성을 동시에 하기 때문에 단 한번만 사용될 수 있고 오직 하나의 객체만을 생성할 수 있는 일회용 클래스

  ```java
  new 조상클래스이름() {
    // 멤버 선언
  }

  new 구현인터페이스이름() {
    // 멤버 선언
  }
  ```

- 이름이 없기 때문에 생성자도 가질 수 없음
- 조상클래스의 이름이나 구현하고자 하는 인터페이스의 이름을 사용하여 정의
  - 하나의 클래스로 상속받는 동시에 인터페이스를 구현하거나 둘 이상의 인터페이스를 구현할 수 없음

## 질문

- 240p static 제어자가 사용될 수 있는 곳
- 240p 인스턴스메서드와 static메서드의 차이점
  - 메서드 내에서 인스턴스 멤버를 사용하는가의 여부
- 241p final 제어자가 사용될 수 있는 곳
- 242p 추상클래스가 인스턴스를 생성할 수 없는 이유
  - 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 미완성 메서드이므로
- 248p 기본형의 형변환은 변수에 저장된 값(주소값)이 변환되는 원리
- 264p 인터페이스는 왜 클래스와 달리 다중상속이 가능한가?
